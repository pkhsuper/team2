제목 : 블렌더에 대한 연구
팀원 :
경영학부/2019116179/박기호/기호
문헌정보학과/2025005260/류혜련/ryu0710
디자인학과/2025012654/여도연/도연
디자인학과/2025005956/장채연/codus.0221
행정학부/2024004657/김유빈/yubin0222

개요 : 블렌더는 3D 모델링, 애니메이션, 렌더링, 영상 편집 등 다양한 기능을 갖춘 통합형 그래픽 툴이다. 지난 10여 년간 빠른 기능 발전과 성능 개선을 이루어 오픈 소스 소프트웨어의 확장성과 지속 가능성을 잘 보여주는 사례로 주목받고 있다. 또한 대규모 사용자 커뮤니티와 다양한 기업 및 단체의 후원을 바탕으로 활발한 개발이 이루어지고 있다.
라이선스 : 완전 무료 자유소프트웨어, GNU GPLv2
  출처 : https://docs.blender.org/manual/en/latest/getting_started/about/license.html

주요기능

1.모델링

모델링은 가상공간에서 3d 입체도형을 만드는 행위로써 모델링 작업에서는 점, 선, 면의 형태를 직접 연결하고, 자르고, 합치고, 나누고, 파 내는 등의 방식을 사용한다. 모델링을 하기 위해서 블렌더는 다양한 모드들을 지원하는데 개체를 이동시키거나 각도를 바꾸게하는 object mode. 꼭짓점, 모서리, 면을 조절할 수 있는 edit mode가 기본이고 이 외에도 점토를 조각하듯 모델링 할 수 있는 sculpt mode, 색을 정할 수 있는 vertex paint mode, texture, particle 등의 모드가 있다. 

  1) 폴리곤 모델링:
     폴리곤 모델링은 모델링방식 중 가장 전통적인 방식으로 게임 그래픽에 많이 사용되는 폴리곤은 다각형이라는 뜻으로 형태를 구성하는 점, 선, 면의 집합으로 메쉬를 제작하는 방식이다. 사물을 표현할 때 다각형의 모임으로 표현하는 것을 말하며 최소단위는 삼각형이지만 작업자가 보기 편한 사각형을 기본 단위로 한다. 폴리곤 방식은 쉽고 직관적이며 표면을 추가하거나 변형하기 쉽다는 장점이 있지만 곡선 표현이 부족하기에 에일리어싱, 즉 계단 현상이라고 하는 화면의 가장자리 부분이 매끄럽지 않게 계단처럼 보이는 현상이 일어난다. 
  
  2) 스플라인 모델링:
  스플라인 모델링은 곡선을 이용하여 개체를 만드는 방식으로 기존의 폴리곤 모델링의 단점을 보안하기 위해 만들어졌다. 스플라인 모델링도 종류가 있는데 폴리 스플라인, 베지어 스플라인과 NURBS 방식이다.

     1) 폴리 스플라인은 제어점 사이에 보간이 없는 가장 간단한 유형이다. 폴리 스플라인은 메쉬를 곡선으로 바꿀때 원래 메쉬를 정확하게 표현하기 위해 사용된다.

     2) 베지어 스플라인 (Bézier):
    베지어 스플라인은 제어점과 핸들을 사용하여 모양을 만들 수 있다. 두 개의 제어점 사이에 곡선 세그먼트가 존재하며 핸들이 곡률을 제어한다. 
    베지어 곡선은 네 가지의 핸들 유형을 지원한다. 
  - Automatic: 가장 부드러운 곡선을 위해 핸들 길이와 뱡향을 자동으로 조정한다. 노란색 손잡이로 표시되며 이동 시 *Aligned*로 변환한다
  - Vector: 핸들이 인접한 제어 지점을 직접 가리키며 직선이나 날카로운 모서리를 가능하게 한다. 초록색 손잡이로 표시되며 이동시 *Free*로 변환한다. 
  - Aligned: 직선 상에 손잡이가 남아있으며 부드럽고 연속적인 곡선이게 한다. 보라색 손잡이로 표시된다.
  - Free: 손잡이가 독립적으로 움직이므로 비대칭 곡선을 만들때 사용되며 검은색 손잡이로 표시된다.
  
    3) NURBS:
  NURBS는 Non-Uniform Rational B-Splineds으로 정확한 모양을 제곡하는 수학적으로 정확한 스플라인이다. 실제 모양에 근사하게 만들어진 베지어 곡선과 다르게 NURBS는 정확히 기하학적으로 모양을 나타낼 수 있다. 수학적으로 선을 그려서 형태를 잡고 그 형태의 선들을 이용해 면을 구현하는 방식이다. NURBS 구조는 유선형의 물체나 생명체 등을 모델링하는 데에 적합한 특성을 가지고 있지만 처리 속도가 폴리곤보다 느리다. 그리고 폴리곤 구조는 근본적으로 삼각형, 사각형을 이용하기 때문에 유선형의 물체에서는 꺾어지는 부분이 만들어지는데 NURBS 구조는 이러한 꺾이는 부분이 발생하지 않으며 객체의 유선형 구조를 곡선 그자체로 구성하게 되고 그래서 이 구조는 보다 완벽한 형태를 필요로 하는 고급 모델링에 사용된다. 정밀한 설계를 할 때 좋지만 렌더링 시 하이 폴리곤으로 전환되어 데이터가 무거워 진다는 단점이 있기 때문에 게임이나 애니메이션에서는 사용하지 않는다. 
  
  3)스컬핑 방식
  스컬핑 방식은 최근 유행하는 모델링 방식으로 점토로 석상을 만들듯이 점토를 빚어 모델링을 하는 방식이다. 그렇기에 매우 직관적인 방식이다. 동식물, 자연물 인간의 신체를 만드는 데에 많이 쓰인다. 2019년까지 스컬프팅 기능은 업계 1위인 ZBrush보다 떨어진다는 평가를 받았지만, 2020년 한 해동안 새로 영입된 개발자인 Pablo Dobarro가 많은 도구와 기능을 추가하여 엄청난 속도로 기능이 개선되는 중이다. 
  
   출처:https://docs.blender.org/manual/en/latest/render/index.html


2.재질 및 텍스처
  1)블렌더의 주요 기능 소개 
    블렌더의 주요 기능 중에는 디자인할 때 기본이 되는 재질(Material) 및 텍스처(Texture)가 있다. 재질과 텍스처를 간단히 소개하자면, 물체의 표면이 주는 느낌이나 시각적 스타일을 뜻한다. 텍스처는 질감이라고도 불리며, 물체를 구성하는 물질의 특성을 반영한다. 그렇다면 블렌더라는 앱에서는 다른 앱과 달리 어떻게 사용되고, 어떻게 프로그램화되는지에 대해 조사해보았다.  
  2)노드의 정의와 사용 예시와 PBR에 관해
    먼저 블렌더에서는 다른 앱과 달리, 재질에서도 레이어 대신 **노드(Node)**라는 방식을 사용한다. 영어로는 Shader Nodes라고 많이들 부른다. 그렇다면 노드란 무엇인지부터 알고 넘어가야 한다. 노드 시스템은 컴퓨터 그래픽 및 게임 제작 프로그램 등에서 광범위하게 사용된다. 블렌더에서는 주로 재질(Materials)을 만드는 데 사용된다.  
    그렇다면 이 노드를 블렌더에서 사용하는 이유는 무엇일까? 답은 프로그래밍에 비해 이해하기 쉽기 때문이다. 여기서 말하는 프로그래밍이란 전통적인 텍스트 기반의 스크립팅이나 코딩을 의미한다. 간단하게 스크립팅에 대해 설명하자면, 스크립트는 작업 자동화, 응용 프로그램 실행 또는 프로그램 내에서 특정 기능 수행에 사용되는 프로그램이다. 또한 서로 다른 소프트웨어 구성 요소를 연결하는 ‘접착제’의 역할을 하여 상호작용하고 함께 작업할 수 있게 해준다.  
    스크립팅은 Python, JavaScript, PowerShell 등 다양한 언어로 사용되며, 블렌더와 비슷한 기능을 가진 포토샵에서도 쓰인다. 그 이유는 사용의 용이성에 있다. 스크립팅 언어는 쉽게 배우고 사용할 수 있도록 설계되었으며, 종종 간단한 문법과 데이터 유형 및 오류 처리에 대한 관용적인 접근 방식을 특징으로 한다. 이를 통해 개발자는 코드를 빠르고 효율적으로 작성할 수 있다.  
    하지만 블렌더에서 프로그래밍 대신 노드를 사용하는 이유는 바로 프로그래밍보다 이해하기 쉬운 시각적 접근 방식을 제공하기 때문이다. 각 노드는 특정 기능이나 연산을 수행하며, 노드 간의 연결을 통해 데이터의 흐름을 직관적으로 파악할 수 있다.  
    이 노드 시스템이 사용되는 대표적인 예로 **서브스턴스 디자이너(Substance Designer)**가 있다. 서브스턴스 디자이너는 노드 기반 시스템이 완전히 구축된 PBR(Physically Based Rendering, 물리 기반 렌더링) 재질 편집 지원 프로그램이다. PBR이란 재질 표면에 따라 빛의 반사 정도가 물리적으로 어떻게 이루어지는지를 시뮬레이션하고, 그것을 시각적으로 표현하는 기법이다. 즉, 컴퓨터 그래픽은 본래 2D로 표현되지만, 이를 더 사실적인 3D로 보이도록 하는 데 목적이 있다.  
    3)PBR 텍스처의 장단점  
      이러한 사실적인 재질 표현을 위해 다양한 텍스처 파일을 한 곳에 모아놓은 것을 **PBR 텍스처(PBR Texture)**라고 한다. PBR을 사용하는 서브스턴스 디자이너의 장점으로는 빠른 작업 속도, 아주 작은 텍스처 용량, 라이브러리화의 용이성, 고해상도 텍스처 작업의 간편함 등이 있다.  
      하지만 단점도 존재한다. 먼저 높은 미술적 관찰력과 논리적 사고를 동시에 요구하며, 툴에 대한 숙련도보다는 코드의 활용 능력이 더욱 중요하다. 또한 결과물에 접근하는 방식이 기존의 그래픽 툴과 전혀 다르다. 이러한 단점들 때문에 일부 전문가들은 노드 기반 시스템이 복잡한 작업에서는 오히려 비효율적일 수 있으며, 전통적인 스크립팅이 더 적합하다고 지적하기도 한다. 이는 노드 시스템이 시각적으로는 직관적이지만, 복잡한 논리를 구현할 때는 노드의 수가 많아져 관리가 어려워질 수 있기 때문이다.  
      4) 블렌더 노드의 인터페이스와 material slots에 관해  
        블렌더 앱에서 사용되는 노드 시스템에 대해 간단히 살펴보자. 블렌더의 노드 시스템에는 **인터페이스(Interface)**와 Material Slots가 있다. 
        먼저 노드 인터페이스는 클러스터에 있는 원격 노드의 구성 요소 집합 또는 개별 구성 요소와 관련된 메트릭을 보고한다. 구성 요소에는 프로세서나 메모리가 포함되며, 개별 구성 요소에는 클러스터의 원격 노드의 프로세서, 네트워크 인터페이스 또는 메모리 페이지가 포함된다.  
        그리고 Material Slots는 여러 개의 재질을 하나의 오브젝트에 추가할 수 있는 기능이다. 각 재질은 각각의 노드를 가지며, 새로운 재질을 추가할 때마다 새로운 노드 그룹이 생성된다.  
        출처:-https://blog.naver.com/blue9954/221052719941
-https://easyitwanner.tistory.com/127
-https://artisticrender.com/the-complete-beginners-guide-to-blender-nodes-eevee-cycles-and-pbr/
-https://m.blog.naver.com/dkdk7422/222715921690
-https://artisticrender.com/the-complete-beginners-guide-to-blender-nodes-eevee-cycles-and-pbr/








3.합성

 합성 노드는 이미지 또는 무차원 단일 값인 데이터에서 작동한다.
예를 들어, 레벨 노드는 단일 값을 출력하는 반면, 렌더 레이어 노드는 이미지를 출력한다. 단일 값을 기대하는 노드 입력은 이미지가 주어졌을 때 기본값을 가정하고 이미지를 완전히 무시한다. Transform 노드는 입력에 단일 값을 기대하고 해당 입력에 이미지가 주어졌을 때 기본값을 가정한다. 기본값은 동일성으로 간주되어 출력에 영향을 미치지 않는 값이므로 Transform 노드의 경우 X, Y, Angle 입력은 기본값이 0인 반면 Scale 입력은 기본값이 1이 된다. 반면에 이미지를 기대하는 노드 입력에 단일 값이 주어지면 단일 값은 전체 합성 공간을 덮는 것으로 가정한다. 예를 들어, Filter 노드는 Factor 입력이 이미지일 것으로 예상하지만 단일 값이 주어지면 모든 픽셀에 대해 동일한 값으로 가정한다.
 
  1) 유형: 
   다양한 유형의 데이터가 존재하며, 모두 반정밀 형식으로 저장된다.
  - Float: 
    부호가 있는 부동 소수점 번호. 정수 유형이 존재하지 않기 때문에 정수 데이터도 부동 소수점으로 저장된다.
  - Vector: 
    4D 벡터이다. 4D이지만 사용하는 노드에 따라 해석이 다를 수 있다. 마지막 두 구성 요소가 무시된 2D 벡터로 처리할 수 있다. 예를 들어 변위 노드의 벡터 입력은 2D 벡터로 
    처리된다. 마지막 구성 요소가 무시된 3D 벡터로 처리할 수 있으며, 분리된 XYZ 노드의 벡터 입력은 3D 벡터로 처리된다. 또한 연속적인 두 개의 2D 벡터로 처리할 수 있다. 
    예를 들어 벡터 블러 노드의 예상대로 속도 패스는 벡터의 X 및 Y 구성 요소에 2D 이전 속도, 벡터의 Z 및 W 구성 요소에 2D 다음 속도를 갖는 것으로 가정한다.
  - Color: 
    빨강, 초록, 파랑, 알파 색상을 저장하는 4D 벡터이다. 색상은 자유 형식이며 특정 색상 공간이나 알파 저장 모델과 일치하지는 않는다. 대신 적절한 노드는 출력의 표현을 
    제어 할 수 있는 설정을 갖게 되고, 노드는 서로 다른 표현 간에 변환할 수 있게 된다.
  - 암묵적 변환: 
    노드 입력에 자신의 유형이 아닌 다른 유형의 데이터가 주어지면 암묵적 변환이 실행된다.
    
  2) 렌더 결과를 후처리(Post-process) 및 수정 시에도 합성 노드를 사용한다.
     - 비네트(Vignette)
     - 섬광(Glare)
     - 빛망울(Bokeh)
     - 색조, 채도, 색상 수정(Color correction)
     - 색상 균형(Color balance)
     - 곡선(Curve)
     - 감마
     - RGB 분리, RGB 혼합
     - 혼합(Mix): Multiply, Overlay, Screen, Lighten, Darken 등 모든 레이어 혼합 모드
     - 이미지 좌표 변형(Translate)
     - 투명도 있는 이미지로 덮어쓰기(Alpha over)
     - 후처리(Post-processing) 노드
       1) 자동 처리: 후처리 노드를 설정하면 렌더할 때마다 자동으로 처리된다.
       2) 자동 저장: 렌더할 때마다 이미지가 자동으로 폴더에 저장된다.
       3) 장면의 여러 카메라 각도 및 애니메이션에 유용하다.
          
          출처: blender 4.4 manual https://docs.blender.org/manual/en/latest/compositing/compositor_system.html#data
          
4.리깅, 애니메이션

 -애니메이션
 
애니메이션은 시간이 지남에 따라 객체가 이동하거나 형태를 변화시키는 것이다. 객체에는 여러 가지 방법으로 애니메이션을 적용할 수 있다

  1) 객체 전체로 이동
시간에 따라 위치, 방향, 크기 변화

  2) 형태 변형
정점이나 제어점을 애니메이션 처리

  3) 종속된 애니메이션
다른 객체의 움직임(예: 부모, 훅, 골격 등)에 따라 객체가 움직이도록 설정

블렌더에서 애니메이션은 일반적으로 키프레임을 사용하여 구현된다.

    -키프레임(Keyframe)
키프레임은 속성 값을 저장하는 시간의 마커이다.
키프레임의 목적은 보간된 애니메이션을 가능하게 하는 것이다. 예를 들어, 사용자는 10번째 프레임에 또 다른 키프레임을 추가하여 큐브의 수평 위치가 20m임을 지정할 수 있고, 블렌더는 선택된 보간 방법(예: 선형, 베지어, 2차 등)에 따라 첫 번째 프레임과 10번째 프레임 사이의 모든 프레임에서 큐브의 올바른 위치를 자동으로 결정한다.

    -시각화(Visualization)
애니메이션을 돕는 중요한 시각화 기능이 3D 뷰포트에 있다. 현재 프레임이 현재 활성 객체의 키프레임인 경우, 3D 뷰포트 왼쪽 상단에 표시된 객체 이름이 노란색으로 변한다.

    -보간(Interpolation)
키프레임 보간은 애니메이션 곡선 또는 F-Curve로 표현되고 제어된다. 이 곡선은 그래프 편집기를 통해 확인하고 수정할 수 있다.


-리깅 (Rigging)

리깅은 애니메이션을 위해 객체에 제어 장치를 추가하는 일반적인 용어이다.
리깅에는 일반적으로 다음 기능들이 포함된다

  1) 골격(Armatures)
메쉬 객체가 유연한 관절을 가질 수 있도록 하며, 이는 종종 골격 애니메이션에 사용된다.

  2) 제약(Constraints)
제어 가능한 움직임을 정의하고, 리그에 기능을 추가하는 데 사용된다.

  3) 객체 수정자(Object Modifiers)
메쉬 변형을 제어하는 여러 수정자가 있으며, 복잡한 변형을 관리할 수 있다.

  4) 셰이프 키(Shape Keys)
얼굴 표정과 같은 다양한 목표 형태를 제어할 수 있도록 지원한다.

  5) 드라이버(Drivers)
리그가 여러 값을 동시에 제어하거나, 다른 곳의 변화에 따라 일부 속성이 자동으로 업데이트되도록 한다.
리깅은 프로젝트 요구 사항에 따라 고급으로 진행할 수 있으며, 리그는 애니메이터가 하위 메커니즘에 대해 걱정하지 않고 사용할 수 있는 사용자 인터페이스를 정한다.

     -골격(Armature)

골격은 리깅을 위한 객체의 한 종류이다. 리그는 마리오네트(인형)을 움직이기 위한 제어 장치이다. 골격 객체는 실제 세계의 골격에서 아이디어를 차용한다.
Blender에서의 골격(Armature)은 실제 골격의 골격처럼 생각할 수 있으며, 실제 골격처럼 여러 개의 뼈대로 구성될 수 있다. 이 뼈들은 움직일 수 있으며, 이들이 연결된 객체도 비슷한 방식으로 이동하고 변형된다.

     -골격 객체(Armature Object)

골격은 Blender의 다른 객체와 마찬가지로 다음과 같은 특징을 갖는다:
원점, 위치, 회전, 크기 비율을 갖는다.
Object Data 데이터 블록을 가지고 있으며, “편집 모드(Edit Mode)“에서 수정할 수 있다.
다른 장면에 링크될 수 있으며, 동일한 골격 데이터를 여러 객체에서 재사용할 수 있다.
”객체 모드(Object Mode)”에서 수행하는 모든 애니메이션은 객체 전체에만 적용되며, 골격의 뼈에는 적용되지 않는다.
골격은 정적인 장면 또는 애니메이션 장면에 사용할 수 있도록 포즈가 지정되며, “기본 위치(rest position)”라는 특정 상태를 갖는다. 이는 골격의 기본 "형태"로, “편집 모드(Edit Mode)”에서 설정된 뼈의 기본 위치/회전/크기를 나타낸다.
“편집 모드(Edit Mode)”에서는 항상 골격이 기본 위치로 표시되며, “객체 모드(Object Mode)”와 “포즈 모드(Pose Mode)”에서는 일반적으로 현재 골격의 "포즈"를 표시한다(기본 위치 버튼을 활성화하지 않은 경우).

    -격자(Lattice)

“격자(Lattice)”는 Blender 외부에서 흔히 "변형 케이지(deformation cage)"라고 불린다. 격자는 렌더링되지 않는 3D 격자 형태의 정점들로 구성된다. 주된 용도는 “격자 수정자(Lattice Modifier)“를 사용해 객체에 변형을 적용하는 것이다. 객체가 ”격자 변형(Lattice Deform)”에 부모로 설정되면, 자동으로 격자 수정자가 적용된다.

    -액션(Actions)

액션은 Blender에서 애니메이션 데이터를 저장하는 컨테이너이다. 예를 들어, 객체의 위치를 애니메이션화할 때, 그 애니메이션은 객체 자체가 아닌 액션에 저장된다. 객체는 그 후 액션을 사용해 애니메이션을 실행하며, 이는 메쉬가 재질을 사용해 쉐이딩을 받는 방식과 유사하다.
액션은 데이터 블록으로, 다른 “블렌드 파일(Blend files)”에 쉽게 추가하거나 연결할 수 있다. 이를 통해 애니메이션 데이터를 저장하고, 정리하며 재사용할 수 있다. 예를 들어, 여러 애니메이션(달리기 사이클, 점프, 대기 등)을 저장하는 라이브러리를 구축하는 경우, 각 애니메이션은 개별 액션에 저장될 수 있으며, 이를 편리하게 링크하거나 별도로 내보낼 수 있다.

    -드라이버(Drivers)

드라이버는 함수나 수학적 표현을 통해 속성의 값을 제어하는 방법이다. 드라이버는 다음과 같이 구성된다:
드라이버 설정: 하나 이상의 입력 값을 다른 속성이나 객체의 변환 채널을 사용하여 지정하고, 이를 미리 정의된 수학적 함수나 사용자 지정 Python 표현식으로 결합한다.
애니메이션 F-Curve: 드라이버 설정의 출력을 최종적으로 적용할 값으로 매핑한다.
예를 들어, 객체 1의 회전은 객체 2의 크기를 통해 제어될 수 있다. 이 경우, 객체 2의 크기가 객체 1의 회전을 제어한다고 할 수 있다.
드라이버는 단순히 하나의 속성 값을 다른 속성 값으로 설정할 수 있을 뿐만 아니라, 여러 값을 고정된 함수나 Python 표현식으로 결합하고, 이를 수동으로 정의된 곡선이나 수정자 스택으로 추가 조정할 수 있다.
드라이버는 리그를 구축하는 데 매우 강력한 도구로, 주로 뼈의 변환, 셰이프 키의 영향, 액션 제약 조건, 수정자를 제어하는 데 사용된다.

    -마커(Markers)

마커는 애니메이션에서 주요 지점이나 중요한 이벤트를 나타내는 데 사용된다. 예를 들어, 캐릭터의 애니메이션이 시작되거나, 카메라가 위치를 변경하거나, 문이 열리는 등의 이벤트가 있을 수 있다. 마커에는 이름을 붙여 빠르게 식별할 수 있다. 마커는 Blender의 여러 편집기에서 사용 가능하다.

    -모션 경로(Motion Paths)

모션 경로 도구는 일련의 프레임에 걸쳐 포인트의 이동 경로를 시각화하는 데 사용된다. 이 포인트들은 객체의 원점이나 뼈의 관절도 포함한다.

출처:https://docs.blender.org/manual/en/latest/index.html




5.렌더링
  렌더링 인쇄와 비슷한 개념으로 작업한 결과물의 정보를 바탕으로 최종 이미지나 영상을 출력하는 것이다. 이러한 렌더링에 있어 블렌더는 무료 오픈 소스 소프트웨어이지만 다른 유료 상용 소프트웨어(Maya나 3DMAX 등) 못지않은 강력한 기능을 보여준다. 블렌더의 렌더링 특징은 다음과 같다.
  1) Eevee 엔진
     블렌더의 렌더링 엔진은 Eevee와 Cycles 두 가지 종류가 대표적이다. Eevee 엔진은 PBR 소재를 렌더링하는 목표를 달성하는 동시에 속도와 상호 작용에 초점을 맞춘 렌더링 엔진이다. 게임 엔진처럼 실시간으로 빠른 렌더링이 가능한 것이 최대 장점이다. 작업 화면에서 보는 정보와 최종 결과물의 정보가 비슷하기 때문에 애니메이션 작업에 유리하고 높은 생산성을 보여준다. 아래 소개할 Cycle 엔진에 비해 사실적인 빛의 움직임은 구현할 수 없지만 여러가지 보조 기능을 더해 비슷하게나마 구현해 고품질 렌더링에 힘을 실어준다.
  2) Cycles 엔진
     물리 기반의 빛 추적 렌더링 기능이다. 빛의 움직임을 추적하여 조명과 반사, 굴절을 현실과 거의 동일한 렌더링을 보여준다. GPU와 CPU를 동시에 사용해 하드웨어의 성능을 극대화할 수 있지 Eevee엔진과 비교했을 때 렌더링 속도가 현저히 느리다. 이러한 단점은 실시간 작업 화면에서 극명하게 드러난다. 작업 도중에 정보를 불러오는 속도가 느려 빠른 작업이 원활하지 않다. 노이즈 제거 기능으로 시각적인 부분을 보조하거나 단순화 기능으로 컴퓨터 성능을 적게 소모하도록 유도해야하는 불편함이 있다. 그러나 사실적인 표현은 Eevee가 따라올 수 없는 성능을 보여주기 때문에 고퀄리티 애니메이션 작업에 있어 많이 선택된다. 단, 빛 추적 기능은 하드웨어의 성능을 매우 많이 사용하기 때문에 작업 환경이 원활하지 않은 사용자에게는 Cycle 엔진 보다는 Eevee 엔진으로 렌더링 하는 것이 권장된다.
  3) Grease Pencil 렌더링
     블렌더는 3D 애니메이션 뿐만 아니라 3D와 2D가 혼합된 애니메이션을 Eevee나 Cycles엔진을 통해 문제없이 렌더링 할 수 있다. 블렌더는 그리즈 펜슬이라는 도구를 통해 2D 작업도 가능한데, 이를 3D 모형들과 함께 어우러져 2D와 3D 두 작업의 장점을 동시에 활용하는 하이브리드 작업이 가능하다. 블렌더를 이용해 2D 렌더링하는 것은 단순히 생산성을 향상시키는 것 외에도 더 많은 가능성을 보여준다. 2D 그림을 3차원으로 역동적으로 움직이게 만들거나 여러가지 Modifier를 적용해 그림에 다양한 방면으로 생기를 불어넣을 수 있다. 또는 현실 세계에 2D 그림을 합성해 렌더링하여 이질적인 결과물을 내보일 수도 있다.
  4) Compositor
     외부 소프트웨어가 없어도 영상의 보정 작업을 Compositer를 통해 쉽게 할 수 있다. Compositer의 노드 설정을 미리 해놓으면 렌더링 결과물에 바로 보정이 적용된다.

     출처 : https://docs.blender.org/manual/en/latest/render/index.html
